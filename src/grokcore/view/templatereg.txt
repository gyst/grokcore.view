Template registry
=================

When grokking views, there is a single global template registry that:

* the grokking process can issue actions to register templates into it.

* the actions that set up views can quickly look up templates from it
  to associate them with views.

* the template registry keeps track of templates that are associated
  with views, or not.

* an action gets registered that gets executed late in configuration
  process that reports on any unassociated templates that are left.

Setup
-----

We create our global template registry once::

  >>> from grokcore.view.templatereg import FileTemplateRegistry
  >>> reg = FileTemplateRegistry()

For testing purposes we will create a directory with two templates in it::

  >>> import os, tempfile
  >>> template_dir = tempfile.mkdtemp()
  >>> f = open(os.path.join(template_dir, 'foo.template'), 'w')
  >>> f.write('foo')
  >>> f.close()
  >>> f = open(os.path.join(template_dir, 'bar.template'), 'w')
  >>> f.write('bar')
  >>> f.close()

Our templates are ``.template``, so we need to register a
``ITemplateFileFactory`` utility for them that knows how to make the
appropriate templates::
    
  >>> from grokcore.view.interfaces import ITemplateFileFactory, ITemplate
  >>> from zope.interface import implements
  >>> class TestTemplate(object):
  ...    implements(ITemplate) # we lie for testing purposes
  ...    def __init__(self, filename, source):
  ...        self.filename = filename
  ...        self.source = source
  ...    def __repr__(self):
  ...        path, filename = os.path.split(self.filename)
  ...        return "<Template '%s' in '%s'>" % (filename, path)
  ...    def __cmp__(self, other):
  ...        return cmp(self.filename, other.filename)
  ...    def _annotateGrokInfo(self, template_name, template_path):
  ...        pass # XXX why do we need to implement this?

  >>> class TestTemplateFactory(object):
  ...    implements(ITemplateFileFactory)
  ...    def __call__(self, filename, _prefix=None):
  ...        f = open(os.path.join(_prefix, filename), 'r')
  ...        data = f.read()
  ...        f.close()
  ...        return TestTemplate(filename, data)

  >>> from zope import component
  >>> component.provideUtility(TestTemplateFactory(), ITemplateFileFactory, 
  ...   name='template')

Registration functions
----------------------

Below we are going to manually create and test template registries. In
a normal run of the application, the global registration functions are
used to register templates. These are ``register_inline_template`` for
inline templates in Python code, and ``register_directory`` for
templates in directories.

Registering a directory
-----------------------

We can now register the filesystem templates with the registry::

  >>> reg.register_directory(template_dir)

We can look up the templates in the registry now::

  >>> reg.lookup(template_dir, 'foo')
  <Template 'foo.template' in '...'>
  >>> reg.lookup(template_dir, 'bar')
  <Template 'bar.template' in '...'>

If we try to look up a template in a directory that doesn't exist, we get
a LookupError::
  
  >>> reg.lookup('certainlydoesntexist', 'foo')
  Traceback (most recent call last):
    ...
  LookupError: template 'foo' in 'certainlydoesntexist' cannot be found

We get this error for templates that do not exist as well::

  >>> reg.lookup(template_dir, 'doesntexist')
  Traceback (most recent call last):
    ...
  LookupError: template 'doesntexist' in ... cannot be found

Since no templates have yet been associated, retrieving the unassociated
templates will get us all registered templates::

  >>> sorted(reg.unassociated())
  ['...bar.template', '...foo.template']

Now we use a template, so we mark it as associated::

  >>> reg.associate(os.path.join(template_dir, 'foo.template'))

There is only a single unassociated template left now::

  >>> sorted(reg.unassociated()) 
  ['...bar.template']

Unknown template extensions
---------------------------

We set up a directory with a template language that is not recognized by
the system::

  >>> import os, tempfile
  >>> template_dir2 = tempfile.mkdtemp()
  >>> f = open(os.path.join(template_dir2, 'foo.unknown'), 'w')
  >>> f.write('unknown')
  >>> f.close()

We will now start recording all the warnings, as we will get one about the
unknown template language when we register the directory later::

  >>> from grokcore.view.testing import warn
  >>> import warnings
  >>> saved_warn = warnings.warn
  >>> warnings.warn = warn

We register the directory now, and we get the warning::

  >>> reg.register_directory(template_dir2)
  From grok.testing's warn():
  ... UserWarning: File 'foo.unknown' has an unrecognized extension in directory '...'
  ...

We restore the normal warnings mechanism::

  >>> warnings.warn = saved_warn

This file will not be loaded as a template::

  >>> reg.lookup(template_dir2, 'foo.unknown')
  Traceback (most recent call last):
    ...
  LookupError: template 'foo.unknown' in '...' cannot be found

Multiple templates with the same name
-------------------------------------

Let's make the template languages ``1`` and ``2`` known::

  >>> component.provideUtility(TestTemplateFactory(), ITemplateFileFactory, 
  ...   name='1')
  >>> component.provideUtility(TestTemplateFactory(), ITemplateFileFactory, 
  ...   name='2')

We now set up a directory which contains 'foo.1' and 'foo.2'. These
templates have the same name but use different template languages, and
Grok won't know which one it should use::

  >>> import os, tempfile
  >>> template_dir3 = tempfile.mkdtemp()
  >>> f = open(os.path.join(template_dir3, 'foo.1'), 'w')
  >>> f.write('1')
  >>> f.close()
  >>> f = open(os.path.join(template_dir3, 'foo.2'), 'w')
  >>> f.write('2')
  >>> f.close()

We expect an error when we register this directory::

  >>> reg.register_directory(template_dir3)
  Traceback (most recent call last):
    ...
  GrokError: Conflicting templates found for name 'foo' in directory '...': 
  multiple templates with the same name and different extensions .

Inline templates
----------------

Inline templates are defined in a Python module instead of on the
filesystem.

First we create a fake ModuleInfo class:

   >>> class ModuleInfo(object):
   ...     dotted_name = 'module'
   ...     name = 'module'
   ...     def __init__(self, dotted_name, name, dir):
   ...         self.dotted_name = dotted_name
   ...         self.name = name
   ...         self.dir = dir
   ...     def getModule(self):
   ...         return None
   ...     def getResourcePath(self, template_dir_name):
   ...         return os.path.join(self.dir, template_dir_name)

an create an instance of this class::

   >>> module_info = ModuleInfo('module', 'module', None)

Let's create a class for inline template and create an instance::

  >>> class InlineTemplate(object):
  ...     def __init__(self, name):
  ...         self.name = name
  ...     def __repr__(self):
  ...         return "<InlineTemplate '%s'>" % self.name
  >>> cavepainting = InlineTemplate('cavepainting')

We create our global inline template registry once::

  >>> from grokcore.view.templatereg import InlineTemplateRegistry
  >>> inline_reg = InlineTemplateRegistry()

Let's register an inline template with the registry::

  >>> inline_reg.register_inline_template(module_info, 'cavepainting', cavepainting)

We can look it up now::

  >>> inline_reg.lookup(module_info, 'cavepainting')
  <InlineTemplate 'cavepainting'>
  
If we cannot find the template we get an error::

  >>> inline_reg.lookup(module_info, 'unknown')
  Traceback (most recent call last):
    ...
  LookupError: inline template 'unknown' in 'module' cannot be found

Since no templates have yet been associated, retrieving the
unassociated templates will get us all registered inline templates::

  >>> sorted(inline_reg.unassociated())
  [('module', 'cavepainting')]

Conflicts between inline templates and file templates
-----------------------------------------------------


We construct a fake templates directory that's associated with the fictional
``module`` module::

  >>> import os, tempfile
  >>> package_dir = tempfile.mkdtemp()
  >>> module_template_dir = os.path.join(package_dir, 'module_templates')
  >>> os.mkdir(module_template_dir)

And we create the module info for this::

   >>> module_info = ModuleInfo('module', 'module', package_dir)

We create a template with the name ``foo`` in it::

  >>> f = open(os.path.join(module_template_dir, 'foo.template'), 'w')
  >>> f.write('foo')
  >>> f.close()

We register this directory, using the global registration functionality::

  >>> from grokcore.view.templatereg import register_directory
  >>> register_directory(module_template_dir)

We now also try to register an inline template with the same name
(``foo``), but this fails due to a conflict with the file template::

  >>> from grokcore.view.templatereg import register_inline_template
  >>> register_inline_template(module_info, 'foo', InlineTemplate('foo'))
  Traceback (most recent call last):
     ...
  GrokError: Conflicting templates found for name 'foo': the inline template 
  in module 'module' conflicts with the file template in directory 
  '...module_templates'





XXX a common lookup function that looks up both inline or filesystem?
